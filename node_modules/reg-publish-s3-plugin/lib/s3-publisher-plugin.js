"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.S3PublisherPlugin = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const zlib_1 = __importDefault(require("zlib"));
const client_s3_1 = require("@aws-sdk/client-s3");
const mkdirp_1 = __importDefault(require("mkdirp"));
const reg_suit_util_1 = require("reg-suit-util");
class S3PublisherPlugin extends reg_suit_util_1.AbstractPublisher {
    constructor() {
        super();
        this.name = "reg-publish-s3-plugin";
    }
    init(config) {
        var _a;
        this.noEmit = config.noEmit;
        this.logger = config.logger;
        this._options = config;
        this._pluginConfig = Object.assign({}, config.options);
        this._s3client = new client_s3_1.S3Client((_a = this._pluginConfig.sdkOptions) !== null && _a !== void 0 ? _a : {});
    }
    publish(key) {
        return this.publishInternal(key).then(({ indexFile }) => {
            const reportUrl = indexFile && `https://${this.getBucketDomain()}/${this.resolveInBucket(key)}/${indexFile.path}`;
            return { reportUrl };
        });
    }
    fetch(key) {
        return this.fetchInternal(key);
    }
    getBucketDomain() {
        if (this._pluginConfig.customDomain) {
            return this._pluginConfig.customDomain;
        }
        else {
            return `${this._pluginConfig.bucketName}.s3.amazonaws.com`;
        }
    }
    getBucketRootDir() {
        return this._pluginConfig.pathPrefix;
    }
    getBucketName() {
        return this._pluginConfig.bucketName;
    }
    getLocalGlobPattern() {
        return this._pluginConfig.pattern;
    }
    getWorkingDirs() {
        return this._options.workingDirs;
    }
    uploadItem(key, item) {
        return new Promise((resolve, reject) => {
            fs_1.default.readFile(item.absPath, (err, content) => {
                if (err)
                    return reject(err);
                zlib_1.default.gzip(content, (err, data) => {
                    if (err)
                        return reject(err);
                    // Enable ACL by default.
                    if (this._pluginConfig.enableACL == undefined) {
                        this._pluginConfig.enableACL = true;
                    }
                    const req = new client_s3_1.PutObjectCommand({
                        Bucket: this._pluginConfig.bucketName,
                        Key: `${key}/${item.path}`,
                        Body: data,
                        ContentType: item.mimeType,
                        ContentEncoding: "gzip",
                        ACL: this._pluginConfig.enableACL ? this._pluginConfig.acl || client_s3_1.ObjectCannedACL.public_read : undefined,
                        SSEKMSKeyId: this._pluginConfig.sseKMSKeyId,
                    });
                    if (this._pluginConfig.sse) {
                        const sseVal = this._pluginConfig.sse;
                        req.input.ServerSideEncryption = typeof sseVal === "string" ? sseVal : client_s3_1.ServerSideEncryption.AES256;
                    }
                    this._s3client
                        .send(req)
                        .then(() => {
                        this.logger.verbose(`Uploaded from ${item.absPath} to ${key}/${item.path}`);
                        return resolve(item);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                });
            });
        });
    }
    downloadItem(remoteItem, item) {
        const s3Key = remoteItem.remotePath;
        return new Promise((resolve, reject) => {
            this._s3client
                .send(new client_s3_1.GetObjectCommand({
                Bucket: this._pluginConfig.bucketName,
                Key: `${s3Key}`,
            }))
                .then((result) => {
                mkdirp_1.default.sync(path_1.default.dirname(item.absPath));
                this._gunzipIfNeed(result, (_err, content) => {
                    if (_err)
                        return reject(_err);
                    fs_1.default.writeFile(item.absPath, content, err => {
                        if (err) {
                            return reject(err);
                        }
                        this.logger.verbose(`Downloaded from ${s3Key} to ${item.absPath}`);
                        resolve(item);
                    });
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    listItems(lastKey, prefix) {
        const options = {
            Bucket: this._pluginConfig.bucketName,
            Prefix: prefix,
            MaxKeys: 1000,
        };
        if (lastKey) {
            options.ContinuationToken = lastKey;
        }
        return new Promise((resolve, reject) => {
            this._s3client
                .send(new client_s3_1.ListObjectsV2Command(options))
                .then((result) => {
                resolve({
                    isTruncated: result.IsTruncated,
                    contents: !result.Contents ? [] : result.Contents.map(f => ({ key: f.Key })),
                    nextMarker: result.NextContinuationToken,
                });
            })
                .catch(err => reject(err));
        });
    }
    _gunzipIfNeed(result, cb) {
        if (!result.Body) {
            cb(new Error("No body returned!"), Buffer.from(""));
        }
        result
            .Body.transformToByteArray()
            .then(body => {
            if (result.ContentEncoding === "gzip") {
                zlib_1.default.gunzip(Buffer.from(body), (err, content) => {
                    cb(err, content);
                });
            }
            else {
                cb(null, Buffer.from(body));
            }
        })
            .catch(err => {
            cb(err, Buffer.from(""));
        });
    }
}
exports.S3PublisherPlugin = S3PublisherPlugin;
//# sourceMappingURL=s3-publisher-plugin.js.map